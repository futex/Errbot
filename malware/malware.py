from errbot import BotPlugin, botcmd, arg_botcmd
from config import BOT_DATA_DIR
import subprocess
import magic
import hashlib
import os
import re
import r2pipe
import socks
import socket
import requests
import configparser
import sys
import importlib
import ast

class malware(BotPlugin):


	#Print message to chat
	def printMessage(self, msg, message):
		if msg.is_direct:
			self.send(msg.frm, message)
		else:
			self.send(msg.to,message)

	#Load all plugins from addin directory
	def load_plugins(self,msg):

		try:
			pysearchre = re.compile('.py$', re.IGNORECASE)
			pluginfiles = filter(pysearchre.search,
		                           os.listdir(os.path.join(os.path.dirname(__file__),
		                                                 'addins')))
			form_module = lambda fp: '.' + os.path.splitext(fp)[0]
			plugins = map(form_module, pluginfiles)

			importlib.import_module('addins')
			modules = []

			for plugin in plugins:

				if not plugin.startswith('__'):
					modules.append(importlib.import_module(plugin, package="addins"))
		
		except Exception as e:
			self.printMessage(msg, "Exception : " + str(e) + ". Line: " + format(sys.exc_info()[-1].tb_lineno))

		return modules

	#Download the sample through TOR
	def download (self, msg, filepath, sample):
			
		try:

			socks.setdefaultproxy(proxy_type=socks.PROXY_TYPE_SOCKS5, addr="127.0.0.1", port=9050)

			r = requests.get(sample, stream=True)

			if r.status_code == 200:
				with open(filepath, 'wb') as f:
					for chunk in r.iter_content(1024):
						f.write(chunk)
			
			else:
				self.printMessage(msg, "Failed to retreive the sample, HTTP code: " + str(r.status_code))
				return

		except socket.timeout as e:
			self.printMessage(msg, "Exception socket.timeout:  " + str(e) + ". Line: " + format(sys.exc_info()[-1].tb_lineno) )
			return

		except socket.error as e:
			self.printMessage(msg, "Exception socket.error:  " + str(e) + ". Line: " + format(sys.exc_info()[-1].tb_lineno) )
			return
		
		except requests.ConnectTimeout as e:
			self.printMessage(msg, "Exception  ConnectTimeout:  " + str(e) + ". Line: " + format(sys.exc_info()[-1].tb_lineno) )
			return

	#Scan YARA
	def yarascan(self, msg, maliciousFile):

		Config = configparser.ConfigParser()
		Config.read("./config.conf")
		YARA_PATH=ast.literal_eval(Config.get("YARA", "YARA_PATH"))
		YARA_RULES_PATH=ast.literal_eval(Config.get("YARA", "YARA_RULES_PATH"))
		YARA_CUSTOM_RULES=ast.literal_eval(Config.get("YARA", "YARA_CUSTOM_RULES"))
			
		output = str(subprocess.Popen([YARA_PATH, "-r", YARA_RULES_PATH + YARA_CUSTOM_RULES, maliciousFile], stdout=subprocess.PIPE).communicate()[0].decode('unicode_escape'))
		hashmd5 = hashlib.md5(open(maliciousFile, 'rb').read()).hexdigest()
		value = output.split(' ')[0]

		if value == "":
			value = "Unknown sample"

		return value, hashmd5

	#Check the malware sample
	def check_malware(self, msg, maliciousFile):
    	
		try:
        	
			mod = self.load_plugins(msg)

			value, hashmd5 = self.yarascan(msg, maliciousFile)
            			
			self.printMessage(msg, value + ", MD5: " + hashmd5)

			for module in mod:
				
				if value.lower() in module.__name__ .lower():

					config = module.get_config(maliciousFile)

					self.printMessage(msg, "Decrypted config: " + config)

			os.system("rm " + maliciousFile)

		except (IndexError, ValueError):
			return 'IndexError: Problem to decrypt the configuration.' + ValueError
		except (IOError):
			return 'IOError: Problem to decrypt the configuration.' + ValueError

	#@arg_botcmd('sample', type=str)
	@botcmd
	def malware(self, msg, sample):

		filepath = "/tmp/mal"
    
		draft_dir = "/tmp/tmp_malw"

		if not os.path.exists(draft_dir):
			os.makedirs(draft_dir)

		#The plugins folder is call addins, because plugins if already use and make an error in errbot
		if not os.path.exists( os.path.dirname(__file__) + '/addins'):
			os.makedirs(os.path.dirname(__file__) + '/addins')

		#If the file come from Internet
		if "http" in sample :

			self.download(msg, filepath, sample)

		#If the file must be uploaded
		else:

			filepath = sample

			#TODO add callback_stream to force bot to download the sample

			#self.send(msg.frm, "Send file: " + sample)
			#self.send_stream_request(msg.frm, open(filepath, 'rb'), name=sample, size=path.getsize(filepath), stream_type='document')


		#Check the filetype
		filetype = magic.from_file(filepath, mime=True)

		#In case of the file in a text file or a script
		if (filetype == "text/x-shellscript" or filetype == "text/plain"):
			f = open(filepath, "r")
			toto=f.read()

			urls = re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', toto)
    
			if urls != "":
                
				for url in urls:
                    
					clean_url = re.sub('[!@#$;&|]', '', url)
                    
					self.printMessage(msg, "Find payload: " + clean_url)

					maliciousFile = draft_dir + "/" + os.path.basename(clean_url)

					r = requests.get(clean_url, stream=True)

					if r.status_code == 200:
						with open(maliciousFile, 'wb') as f:
							for chunk in r.iter_content(1024):
								f.write(chunk)

					self.check_malware(msg, maliciousFile)

			else:
				self.printMessage(msg, "Can't find url in the file")

		#Check if the file is a Unix exectuable or a windows PE
		elif (filetype == "application/x-executable" or filetype == "application/x-dosexec"):
			self.check_malware(msg, filepath)